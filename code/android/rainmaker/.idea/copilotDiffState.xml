<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/GeneratorViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/GeneratorViewModel.kt" />
              <option name="originalContent" value="package com.seattledevcamp.rainmaker&#10;&#10;import android.app.Application&#10;import android.media.MediaPlayer&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.File&#10;import com.seattledevcamp.rainmaker.audio.RainGenerator&#10;import com.seattledevcamp.rainmaker.audio.WavWriter&#10;&#10;class GeneratorViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _status = MutableStateFlow(&quot;idle&quot;)&#10;    val status = _status.asStateFlow()&#10;&#10;    private val _recordings = MutableStateFlow&lt;List&lt;File&gt;&gt;(emptyList())&#10;    val recordings = _recordings.asStateFlow()&#10;&#10;    private var player: MediaPlayer? = null&#10;&#10;    init {&#10;        refreshList()&#10;    }&#10;&#10;    fun generateRainFile(durationSec: Int, intensityCode: Int, modifiers: Int, filename: String) {&#10;        _status.value = &quot;starting&quot;&#10;        val file = File(getApplication&lt;Application&gt;().filesDir, filename)&#10;        Thread {&#10;            try {&#10;                _status.value = &quot;generating&quot;&#10;                val ok = try {&#10;                    // Call native bridge if available&#10;                    NativeBridge.generate(file.absolutePath, 44100, durationSec, intensityCode, modifiers)&#10;                } catch (_: Throwable) {&#10;                    // Fallback: generate WAV in pure Kotlin&#10;                    val pcm = RainGenerator.generate(44100, durationSec, intensityCode, modifiers)&#10;                    WavWriter.writeWav(getApplication(), filename, 44100, pcm)&#10;                    true&#10;                }&#10;                if (ok) {&#10;                    _status.value = &quot;saved:${file.absolutePath}&quot;&#10;                } else {&#10;                    _status.value = &quot;error:native-failed&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _status.value = &quot;error:${e.message}&quot;&#10;            } finally {&#10;                refreshList()&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    fun refreshList() {&#10;        val files = getApplication&lt;Application&gt;().filesDir.listFiles { f -&gt; f.extension.equals(&quot;wav&quot;, ignoreCase = true) }?.toList() ?: emptyList()&#10;        _recordings.value = files.sortedByDescending { it.lastModified() }&#10;    }&#10;&#10;    fun playFile(file: File) {&#10;        try {&#10;            player?.release()&#10;            player = MediaPlayer().apply {&#10;                setDataSource(file.absolutePath)&#10;                prepare()&#10;                start()&#10;            }&#10;            _status.value = &quot;playing:${file.name}&quot;&#10;        } catch (e: Exception) {&#10;            _status.value = &quot;error:${e.message}&quot;&#10;        }&#10;    }&#10;&#10;    fun deleteFile(file: File) {&#10;        if (file.exists() &amp;&amp; file.delete()) {&#10;            _status.value = &quot;deleted:${file.name}&quot;&#10;            refreshList()&#10;        } else {&#10;            _status.value = &quot;error:delete failed&quot;&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        player?.release()&#10;        super.onCleared()&#10;    }&#10;&#10;    class Factory(private val app: Application) : ViewModelProvider.Factory {&#10;        @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;            return GeneratorViewModel(app) as T&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.seattledevcamp.rainmaker&#10;&#10;import android.app.Application&#10;import android.media.MediaPlayer&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.File&#10;import com.seattledevcamp.rainmaker.audio.RainGenerator&#10;import com.seattledevcamp.rainmaker.audio.WavWriter&#10;&#10;class GeneratorViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _status = MutableStateFlow(&quot;idle&quot;)&#10;    val status = _status.asStateFlow()&#10;&#10;    private val _recordings = MutableStateFlow&lt;List&lt;File&gt;&gt;(emptyList())&#10;    val recordings = _recordings.asStateFlow()&#10;&#10;    // Playback state&#10;    private val _currentPlaying = MutableStateFlow&lt;String?&gt;(null)&#10;    val currentPlaying = _currentPlaying.asStateFlow()&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying = _isPlaying.asStateFlow()&#10;&#10;    private var player: MediaPlayer? = null&#10;&#10;    init {&#10;        refreshList()&#10;    }&#10;&#10;    fun generateRainFile(durationSec: Int, intensityCode: Int, modifiers: Int, filename: String) {&#10;        _status.value = &quot;starting&quot;&#10;        val file = File(getApplication&lt;Application&gt;().filesDir, filename)&#10;        Thread {&#10;            try {&#10;                _status.value = &quot;generating&quot;&#10;                val ok = try {&#10;                    // Call native bridge if available&#10;                    NativeBridge.generate(file.absolutePath, 44100, durationSec, intensityCode, modifiers)&#10;                } catch (_: Throwable) {&#10;                    // Fallback: generate WAV in pure Kotlin&#10;                    val pcm = RainGenerator.generate(44100, durationSec, intensityCode, modifiers)&#10;                    WavWriter.writeWav(getApplication(), filename, 44100, pcm)&#10;                    true&#10;                }&#10;                if (ok) {&#10;                    _status.value = &quot;saved:${file.absolutePath}&quot;&#10;                } else {&#10;                    _status.value = &quot;error:native-failed&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _status.value = &quot;error:${e.message}&quot;&#10;            } finally {&#10;                refreshList()&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    fun refreshList() {&#10;        val files = getApplication&lt;Application&gt;().filesDir.listFiles { f -&gt; f.extension.equals(&quot;wav&quot;, ignoreCase = true) }?.toList() ?: emptyList()&#10;        _recordings.value = files.sortedByDescending { it.lastModified() }&#10;    }&#10;&#10;    /** Toggle playback for a file: play if not playing, pause if playing the same file, switch otherwise. */&#10;    fun togglePlay(file: File) {&#10;        try {&#10;            val path = file.absolutePath&#10;            // If same file&#10;            if (_currentPlaying.value == path) {&#10;                // toggle pause/resume&#10;                if (player?.isPlaying == true) {&#10;                    player?.pause()&#10;                    _isPlaying.value = false&#10;                    _status.value = &quot;paused:${file.name}&quot;&#10;                } else {&#10;                    player?.start()&#10;                    _isPlaying.value = true&#10;                    _status.value = &quot;playing:${file.name}&quot;&#10;                }&#10;                return&#10;            }&#10;&#10;            // Different file: stop previous and start new&#10;            player?.release()&#10;            player = MediaPlayer().apply {&#10;                setDataSource(path)&#10;                prepare()&#10;                start()&#10;            }&#10;            _currentPlaying.value = path&#10;            _isPlaying.value = true&#10;            _status.value = &quot;playing:${file.name}&quot;&#10;        } catch (e: Exception) {&#10;            _status.value = &quot;error:${e.message}&quot;&#10;        }&#10;    }&#10;&#10;    fun deleteFile(file: File) {&#10;        // If deleting the currently playing file, stop playback&#10;        try {&#10;            val path = file.absolutePath&#10;            if (_currentPlaying.value == path) {&#10;                player?.stop()&#10;                player?.release()&#10;                player = null&#10;                _currentPlaying.value = null&#10;                _isPlaying.value = false&#10;            }&#10;        } catch (_: Exception) {&#10;            // ignore&#10;        }&#10;&#10;        if (file.exists() &amp;&amp; file.delete()) {&#10;            _status.value = &quot;deleted:${file.name}&quot;&#10;            refreshList()&#10;        } else {&#10;            _status.value = &quot;error:delete failed&quot;&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        player?.release()&#10;        super.onCleared()&#10;    }&#10;&#10;    class Factory(private val app: Application) : ViewModelProvider.Factory {&#10;        @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;            return GeneratorViewModel(app) as T&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>