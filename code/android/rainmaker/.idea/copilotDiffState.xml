<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/GeneratorViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/GeneratorViewModel.kt" />
              <option name="originalContent" value="package com.seattledevcamp.rainmaker&#10;&#10;import android.app.Application&#10;import android.media.MediaPlayer&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.File&#10;import com.seattledevcamp.rainmaker.audio.RainGenerator&#10;import com.seattledevcamp.rainmaker.audio.WavWriter&#10;&#10;class GeneratorViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _status = MutableStateFlow(&quot;idle&quot;)&#10;    val status = _status.asStateFlow()&#10;&#10;    private val _recordings = MutableStateFlow&lt;List&lt;File&gt;&gt;(emptyList())&#10;    val recordings = _recordings.asStateFlow()&#10;&#10;    // Playback state&#10;    private val _currentPlaying = MutableStateFlow&lt;String?&gt;(null)&#10;    val currentPlaying = _currentPlaying.asStateFlow()&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying = _isPlaying.asStateFlow()&#10;&#10;    private var player: MediaPlayer? = null&#10;&#10;    init {&#10;        refreshList()&#10;    }&#10;&#10;    fun generateRainFile(durationSec: Int, intensityCode: Int, modifiers: Int, filename: String) {&#10;        _status.value = &quot;starting&quot;&#10;        val file = File(getApplication&lt;Application&gt;().filesDir, filename)&#10;        Thread {&#10;            try {&#10;                _status.value = &quot;generating&quot;&#10;                val ok = try {&#10;                    // Call native bridge if available&#10;                    NativeBridge.generate(file.absolutePath, 44100, durationSec, intensityCode, modifiers)&#10;                } catch (_: Throwable) {&#10;                    // Fallback: generate WAV in pure Kotlin&#10;                    val pcm = RainGenerator.generate(44100, durationSec, intensityCode, modifiers)&#10;                    WavWriter.writeWav(getApplication(), filename, 44100, pcm)&#10;                    true&#10;                }&#10;                if (ok) {&#10;                    _status.value = &quot;saved:${file.absolutePath}&quot;&#10;                } else {&#10;                    _status.value = &quot;error:native-failed&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _status.value = &quot;error:${e.message}&quot;&#10;            } finally {&#10;                refreshList()&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    fun refreshList() {&#10;        val files = getApplication&lt;Application&gt;().filesDir.listFiles { f -&gt; f.extension.equals(&quot;wav&quot;, ignoreCase = true) }?.toList() ?: emptyList()&#10;        _recordings.value = files.sortedByDescending { it.lastModified() }&#10;    }&#10;&#10;    /** Toggle playback for a file: play if not playing, pause if playing the same file, switch otherwise. */&#10;    fun togglePlay(file: File) {&#10;        try {&#10;            val path = file.absolutePath&#10;            // If same file&#10;            if (_currentPlaying.value == path) {&#10;                // toggle pause/resume&#10;                if (player?.isPlaying == true) {&#10;                    player?.pause()&#10;                    _isPlaying.value = false&#10;                    _status.value = &quot;paused:${file.name}&quot;&#10;                } else {&#10;                    player?.start()&#10;                    _isPlaying.value = true&#10;                    _status.value = &quot;playing:${file.name}&quot;&#10;                }&#10;                return&#10;            }&#10;&#10;            // Different file: stop previous and start new&#10;            player?.release()&#10;            player = MediaPlayer().apply {&#10;                setDataSource(path)&#10;                prepare()&#10;                start()&#10;            }&#10;            _currentPlaying.value = path&#10;            _isPlaying.value = true&#10;            _status.value = &quot;playing:${file.name}&quot;&#10;        } catch (e: Exception) {&#10;            _status.value = &quot;error:${e.message}&quot;&#10;        }&#10;    }&#10;&#10;    fun deleteFile(file: File) {&#10;        // If deleting the currently playing file, stop playback&#10;        try {&#10;            val path = file.absolutePath&#10;            if (_currentPlaying.value == path) {&#10;                player?.stop()&#10;                player?.release()&#10;                player = null&#10;                _currentPlaying.value = null&#10;                _isPlaying.value = false&#10;            }&#10;        } catch (_: Exception) {&#10;            // ignore&#10;        }&#10;&#10;        if (file.exists() &amp;&amp; file.delete()) {&#10;            _status.value = &quot;deleted:${file.name}&quot;&#10;            refreshList()&#10;        } else {&#10;            _status.value = &quot;error:delete failed&quot;&#10;        }&#10;    }&#10;&#10;    fun updateStatus(message: String) {&#10;        _status.value = message&#10;    }&#10;&#10;    override fun onCleared() {&#10;        player?.release()&#10;        super.onCleared()&#10;    }&#10;&#10;    class Factory(private val app: Application) : ViewModelProvider.Factory {&#10;        @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;            return GeneratorViewModel(app) as T&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.seattledevcamp.rainmaker&#10;&#10;import android.app.Application&#10;import android.media.MediaPlayer&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.ViewModelProvider&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import java.io.File&#10;import com.seattledevcamp.rainmaker.audio.RainGenerator&#10;import com.seattledevcamp.rainmaker.audio.WavWriter&#10;&#10;class GeneratorViewModel(application: Application) : AndroidViewModel(application) {&#10;    private val _status = MutableStateFlow(&quot;idle&quot;)&#10;    val status = _status.asStateFlow()&#10;&#10;    private val _recordings = MutableStateFlow&lt;List&lt;File&gt;&gt;(emptyList())&#10;    val recordings = _recordings.asStateFlow()&#10;&#10;    // Playback state&#10;    private val _currentPlaying = MutableStateFlow&lt;String?&gt;(null)&#10;    val currentPlaying = _currentPlaying.asStateFlow()&#10;    private val _isPlaying = MutableStateFlow(false)&#10;    val isPlaying = _isPlaying.asStateFlow()&#10;&#10;    private var player: MediaPlayer? = null&#10;&#10;    init {&#10;        refreshList()&#10;    }&#10;&#10;    fun generateRainFile(durationSec: Int, intensityCode: Int, modifiers: Int, filename: String, seed: Long = kotlin.random.Random.nextLong()) {&#10;        _status.value = &quot;starting&quot;&#10;        val file = File(getApplication&lt;Application&gt;().filesDir, filename)&#10;        Thread {&#10;            try {&#10;                _status.value = &quot;generating&quot;&#10;                val ok = try {&#10;                    // Prefer seed-aware native if present&#10;                    try {&#10;                        NativeBridge.generateWithSeed(file.absolutePath, 44100, durationSec, intensityCode, modifiers, seed)&#10;                    } catch (t: Throwable) {&#10;                        // Fallback to legacy native&#10;                        NativeBridge.generate(file.absolutePath, 44100, durationSec, intensityCode, modifiers)&#10;                    }&#10;                } catch (t: Throwable) {&#10;                    // Fallback: generate WAV in pure Kotlin using provided seed&#10;                    val pcm = RainGenerator.generate(44100, durationSec, intensityCode, modifiers, seed)&#10;                    WavWriter.writeWav(getApplication(), filename, 44100, pcm)&#10;                    true&#10;                }&#10;                if (ok) {&#10;                    _status.value = &quot;saved:${file.absolutePath}:seed=$seed&quot;&#10;                } else {&#10;                    _status.value = &quot;error:native-failed&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                _status.value = &quot;error:${e.message}&quot;&#10;            } finally {&#10;                refreshList()&#10;            }&#10;        }.start()&#10;    }&#10;&#10;    fun refreshList() {&#10;        val files = getApplication&lt;Application&gt;().filesDir.listFiles { f -&gt; f.extension.equals(&quot;wav&quot;, ignoreCase = true) }?.toList() ?: emptyList()&#10;        _recordings.value = files.sortedByDescending { it.lastModified() }&#10;    }&#10;&#10;    /** Toggle playback for a file: play if not playing, pause if playing the same file, switch otherwise. */&#10;    fun togglePlay(file: File) {&#10;        try {&#10;            val path = file.absolutePath&#10;            // If same file&#10;            if (_currentPlaying.value == path) {&#10;                // toggle pause/resume&#10;                if (player?.isPlaying == true) {&#10;                    player?.pause()&#10;                    _isPlaying.value = false&#10;                    _status.value = &quot;paused:${file.name}&quot;&#10;                } else {&#10;                    player?.start()&#10;                    _isPlaying.value = true&#10;                    _status.value = &quot;playing:${file.name}&quot;&#10;                }&#10;                return&#10;            }&#10;&#10;            // Different file: stop previous and start new&#10;            player?.release()&#10;            player = MediaPlayer().apply {&#10;                setDataSource(path)&#10;                prepare()&#10;                start()&#10;            }&#10;            _currentPlaying.value = path&#10;            _isPlaying.value = true&#10;            _status.value = &quot;playing:${file.name}&quot;&#10;        } catch (e: Exception) {&#10;            _status.value = &quot;error:${e.message}&quot;&#10;        }&#10;    }&#10;&#10;    fun deleteFile(file: File) {&#10;        // If deleting the currently playing file, stop playback&#10;        try {&#10;            val path = file.absolutePath&#10;            if (_currentPlaying.value == path) {&#10;                player?.stop()&#10;                player?.release()&#10;                player = null&#10;                _currentPlaying.value = null&#10;                _isPlaying.value = false&#10;            }&#10;        } catch (_: Exception) {&#10;            // ignore&#10;        }&#10;&#10;        if (file.exists() &amp;&amp; file.delete()) {&#10;            _status.value = &quot;deleted:${file.name}&quot;&#10;            refreshList()&#10;        } else {&#10;            _status.value = &quot;error:delete failed&quot;&#10;        }&#10;    }&#10;&#10;    fun updateStatus(message: String) {&#10;        _status.value = message&#10;    }&#10;&#10;    override fun onCleared() {&#10;        player?.release()&#10;        super.onCleared()&#10;    }&#10;&#10;    class Factory(private val app: Application) : ViewModelProvider.Factory {&#10;        @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;        override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;            return GeneratorViewModel(app) as T&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/MainActivity.kt" />
              <option name="originalContent" value="package com.seattledevcamp.rainmaker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import java.io.File&#10;&#10;enum class RainIntensity(val code: Int, val label: String) {&#10;    LIGHT(0, &quot;Light&quot;), MEDIUM(1, &quot;Medium&quot;), HEAVY(2, &quot;Heavy&quot;)&#10;}&#10;&#10;enum class Screen {&#10;    GENERATOR, RECORDINGS&#10;}&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            MaterialTheme {&#10;                val vm: GeneratorViewModel = viewModel&lt;GeneratorViewModel&gt;(factory = GeneratorViewModel.Factory(application))&#10;                val status by vm.status.collectAsState(initial = &quot;idle&quot;)&#10;                val recordings by vm.recordings.collectAsState(initial = emptyList())&#10;                val currentPlaying by vm.currentPlaying.collectAsState(initial = null)&#10;                val isPlayingGlobal by vm.isPlaying.collectAsState(initial = false)&#10;&#10;                var currentScreen by remember { mutableStateOf(Screen.GENERATOR) }&#10;&#10;                var selectedIntensity by remember { mutableStateOf(RainIntensity.MEDIUM) }&#10;                val modifiers = remember {&#10;                    mutableStateMapOf(&#10;                        &quot;sea&quot; to false,&#10;                        &quot;cliffs&quot; to false,&#10;                        &quot;forest&quot; to false,&#10;                        &quot;river&quot; to false,&#10;                        &quot;city&quot; to false,&#10;                        &quot;countryside&quot; to false,&#10;                        &quot;cafe&quot; to false&#10;                    )&#10;                }&#10;                var durationSec by remember { mutableStateOf(30f) }&#10;&#10;                // Auto-navigate to recordings when generation completes with saved:path&#10;                LaunchedEffect(status) {&#10;                    if (status.startsWith(&quot;saved:&quot;)) {&#10;                        currentScreen = Screen.RECORDINGS&#10;                        vm.refreshList()&#10;                    }&#10;                }&#10;&#10;                Scaffold(&#10;                    topBar = {&#10;                        AppTopBar(&#10;                            currentScreen = currentScreen,&#10;                            onOpenRecordings = { currentScreen = Screen.RECORDINGS },&#10;                            onBack = { currentScreen = Screen.GENERATOR }&#10;                        )&#10;                    },&#10;                    content = { innerPadding -&gt;&#10;                        Box(modifier = Modifier.padding(innerPadding).fillMaxSize()) {&#10;                            when (currentScreen) {&#10;                                Screen.GENERATOR -&gt; GeneratorContent(&#10;                                    selectedIntensity = selectedIntensity,&#10;                                    onSelectIntensity = { selectedIntensity = it },&#10;                                    modifiers = modifiers,&#10;                                    durationSec = durationSec,&#10;                                    onDurationChange = { durationSec = it },&#10;                                    onGenerate = {&#10;                                        val mask = modifiers.entries.fold(0) { acc, e -&gt; if (e.value) acc or modifierMask(e.key) else acc }&#10;                                        val filename = &quot;rain_${System.currentTimeMillis()}.wav&quot;&#10;                                        vm.generateRainFile(durationSec.toInt(), selectedIntensity.code, mask, filename)&#10;                                    },&#10;                                    status = status,&#10;                                    onRefresh = { vm.refreshList() }&#10;                                )&#10;                                Screen.RECORDINGS -&gt; RecordingsContent(&#10;                                    recordings = recordings,&#10;                                    currentPlaying = currentPlaying,&#10;                                    isPlayingGlobal = isPlayingGlobal,&#10;                                    onPlay = { vm.togglePlay(it) },&#10;                                    onDelete = { vm.deleteFile(it) },&#10;                                    onRefresh = { vm.refreshList() },&#10;                                    onRename = { file, newName -&gt;&#10;                                        val trimmed = newName.trim()&#10;                                        if (trimmed.isNotEmpty()) {&#10;                                            val safeName = if (trimmed.endsWith(&quot;.wav&quot;, ignoreCase = true)) trimmed else &quot;$trimmed.wav&quot;&#10;                                            val dir = file.parentFile&#10;                                            if (dir != null) {&#10;                                                val target = File(dir, safeName)&#10;                                                when {&#10;                                                    target.exists() -&gt; vm.updateStatus(&quot;error: rename target exists&quot;)&#10;                                                    file.renameTo(target) -&gt; {&#10;                                                        vm.updateStatus(&quot;renamed:${target.name}&quot;)&#10;                                                    }&#10;                                                    else -&gt; {&#10;                                                        vm.updateStatus(&quot;error: rename failed&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        vm.refreshList()&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun modifierMask(key: String): Int {&#10;        return when (key) {&#10;            &quot;sea&quot; -&gt; 1 shl 0&#10;            &quot;cliffs&quot; -&gt; 1 shl 1&#10;            &quot;forest&quot; -&gt; 1 shl 2&#10;            &quot;river&quot; -&gt; 1 shl 3&#10;            &quot;city&quot; -&gt; 1 shl 4&#10;            &quot;countryside&quot; -&gt; 1 shl 5&#10;            &quot;cafe&quot; -&gt; 1 shl 6&#10;            else -&gt; 0&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun GeneratorContent(&#10;    selectedIntensity: RainIntensity,&#10;    onSelectIntensity: (RainIntensity) -&gt; Unit,&#10;    modifiers: MutableMap&lt;String, Boolean&gt;,&#10;    durationSec: Float,&#10;    onDurationChange: (Float) -&gt; Unit,&#10;    onGenerate: () -&gt; Unit,&#10;    status: String,&#10;    onRefresh: () -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.padding(16.dp).verticalScroll(rememberScrollState())) {&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Text(&quot;Intensity&quot;)&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            listOf(RainIntensity.LIGHT, RainIntensity.MEDIUM, RainIntensity.HEAVY).forEach { r -&gt;&#10;                val isSelected = r == selectedIntensity&#10;                Button(&#10;                    onClick = { onSelectIntensity(r) },&#10;                    modifier = Modifier.weight(1f),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = if (isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondaryContainer,&#10;                        contentColor = if (isSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSecondary&#10;                    )&#10;                ) {&#10;                    Text(r.label)&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;        Text(&quot;Modifiers (environment)&quot;)&#10;        FlowRow(modifiers.keys.toList()) { key -&gt;&#10;            val checked = modifiers[key] ?: false&#10;            FilterChip(selected = checked, onClick = { modifiers[key] = !checked }, label = { Text(key) })&#10;        }&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;        Text(&quot;Duration: ${durationSec.toInt()}s&quot;)&#10;        Slider(value = durationSec, onValueChange = onDurationChange, valueRange = 10f..3000f)&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            Button(onClick = onGenerate) { Text(&quot;Generate&quot;) }&#10;            Button(onClick = onRefresh) { Text(&quot;Refresh&quot;) }&#10;        }&#10;&#10;        Spacer(Modifier.height(8.dp))&#10;        Text(&quot;Status: $status&quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RecordingsContent(&#10;    recordings: List&lt;File&gt;,&#10;    currentPlaying: String?,&#10;    isPlayingGlobal: Boolean,&#10;    onPlay: (File) -&gt; Unit,&#10;    onDelete: (File) -&gt; Unit,&#10;    onRefresh: () -&gt; Unit,&#10;    onRename: (File, String) -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.padding(16.dp)) {&#10;        Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {&#10;            Text(&quot;Recordings&quot;, style = MaterialTheme.typography.titleMedium)&#10;            Button(onClick = onRefresh) { Text(&quot;Refresh&quot;) }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;        LazyColumn(verticalArrangement = Arrangement.spacedBy(4.dp)) {&#10;            items(recordings) { f -&gt;&#10;                val playingForThis = (currentPlaying == f.absolutePath) &amp;&amp; isPlayingGlobal&#10;                RecordingRow(&#10;                    file = f,&#10;                    isPlaying = playingForThis,&#10;                    onTogglePlay = { onPlay(f) },&#10;                    onDelete = { onDelete(f) },&#10;                    onRename = { newName -&gt; onRename(f, newName) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FlowRow(keys: List&lt;String&gt;, content: @Composable (String) -&gt; Unit) {&#10;    Column {&#10;        val maxPerRow = 3&#10;        keys.chunked(maxPerRow).forEach { chunk -&gt;&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                chunk.forEach { key -&gt; content(key) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun RecordingRow(&#10;    file: File,&#10;    isPlaying: Boolean,&#10;    onTogglePlay: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit,&#10;    onRename: (String) -&gt; Unit&#10;) {&#10;    var showRenameDialog by remember { mutableStateOf(false) }&#10;    var newName by remember { mutableStateOf(file.name) }&#10;&#10;    Card(modifier = Modifier&#10;        .fillMaxWidth()&#10;        .padding(vertical = 4.dp)) {&#10;        Row(&#10;            modifier = Modifier&#10;                .padding(12.dp)&#10;                .fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Column {&#10;                Text(file.name, style = MaterialTheme.typography.bodyLarge)&#10;                Text(&quot;${file.length() / 1024} KB&quot;, style = MaterialTheme.typography.bodySmall)&#10;            }&#10;            Row {&#10;                if (isPlaying) {&#10;                    TextButton(onClick = onTogglePlay) { Text(&quot;Pause&quot;) }&#10;                } else {&#10;                    IconButton(onClick = onTogglePlay) { Icon(Icons.Default.PlayArrow, contentDescription = &quot;Play&quot;) }&#10;                }&#10;                IconButton(onClick = { showRenameDialog = true }) {&#10;                    Icon(Icons.Default.Edit, contentDescription = &quot;Rename&quot;)&#10;                }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = &quot;Delete&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showRenameDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showRenameDialog = false },&#10;            title = { Text(&quot;Rename recording&quot;) },&#10;            text = {&#10;                Column {&#10;                    Text(&quot;Enter a new name (without extension). .wav will be added if missing.&quot;)&#10;                    Spacer(Modifier.height(8.dp))&#10;                    TextField(value = newName, onValueChange = { newName = it }, singleLine = true)&#10;                }&#10;            },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    onRename(newName)&#10;                    showRenameDialog = false&#10;                }) {&#10;                    Text(&quot;OK&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showRenameDialog = false }) { Text(&quot;Cancel&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AppTopBar(currentScreen: Screen, onOpenRecordings: () -&gt; Unit, onBack: () -&gt; Unit) {&#10;    Surface(tonalElevation = 4.dp, modifier = Modifier.fillMaxWidth()) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                if (currentScreen == Screen.GENERATOR) &quot;Rain Mix Generator&quot; else &quot;Recordings&quot;,&#10;                style = MaterialTheme.typography.titleLarge&#10;            )&#10;            if (currentScreen == Screen.GENERATOR) {&#10;                TextButton(onClick = onOpenRecordings) { Text(&quot;Recordings&quot;) }&#10;            } else {&#10;                TextButton(onClick = onBack) { Text(&quot;Back&quot;) }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.seattledevcamp.rainmaker&#10;&#10;import android.os.Bundle&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Delete&#10;import androidx.compose.material.icons.filled.Edit&#10;import androidx.compose.material.icons.filled.PlayArrow&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import java.io.File&#10;&#10;enum class RainIntensity(val code: Int, val label: String) {&#10;    LIGHT(0, &quot;Light&quot;), MEDIUM(1, &quot;Medium&quot;), HEAVY(2, &quot;Heavy&quot;)&#10;}&#10;&#10;enum class Screen {&#10;    GENERATOR, RECORDINGS&#10;}&#10;&#10;class MainActivity : ComponentActivity() {&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContent {&#10;            MaterialTheme {&#10;                val vm: GeneratorViewModel = viewModel&lt;GeneratorViewModel&gt;(factory = GeneratorViewModel.Factory(application))&#10;                val status by vm.status.collectAsState(initial = &quot;idle&quot;)&#10;                val recordings by vm.recordings.collectAsState(initial = emptyList())&#10;                val currentPlaying by vm.currentPlaying.collectAsState(initial = null)&#10;                val isPlayingGlobal by vm.isPlaying.collectAsState(initial = false)&#10;&#10;                var currentScreen by remember { mutableStateOf(Screen.GENERATOR) }&#10;&#10;                var selectedIntensity by remember { mutableStateOf(RainIntensity.MEDIUM) }&#10;                val modifiers = remember {&#10;                    mutableStateMapOf(&#10;                        &quot;sea&quot; to false,&#10;                        &quot;cliffs&quot; to false,&#10;                        &quot;forest&quot; to false,&#10;                        &quot;river&quot; to false,&#10;                        &quot;city&quot; to false,&#10;                        &quot;countryside&quot; to false,&#10;                        &quot;cafe&quot; to false&#10;                    )&#10;                }&#10;                var durationSec by remember { mutableStateOf(30f) }&#10;&#10;                // Auto-navigate to recordings when generation completes with saved:path&#10;                LaunchedEffect(status) {&#10;                    if (status.startsWith(&quot;saved:&quot;)) {&#10;                        currentScreen = Screen.RECORDINGS&#10;                        vm.refreshList()&#10;                    }&#10;                }&#10;&#10;                Scaffold(&#10;                    topBar = {&#10;                        AppTopBar(&#10;                            currentScreen = currentScreen,&#10;                            onOpenRecordings = { currentScreen = Screen.RECORDINGS },&#10;                            onBack = { currentScreen = Screen.GENERATOR }&#10;                        )&#10;                    },&#10;                    content = { innerPadding -&gt;&#10;                        Box(modifier = Modifier.padding(innerPadding).fillMaxSize()) {&#10;                            when (currentScreen) {&#10;                                Screen.GENERATOR -&gt; GeneratorContent(&#10;                                    selectedIntensity = selectedIntensity,&#10;                                    onSelectIntensity = { selectedIntensity = it },&#10;                                    modifiers = modifiers,&#10;                                    durationSec = durationSec,&#10;                                    onDurationChange = { durationSec = it },&#10;                                    onGenerate = {&#10;                                        val mask = modifiers.entries.fold(0) { acc, e -&gt; if (e.value) acc or modifierMask(e.key) else acc }&#10;                                        val seed = kotlin.random.Random.nextLong()&#10;                                        val filename = &quot;rain_${System.currentTimeMillis()}_${kotlin.math.abs(seed)}.wav&quot;&#10;                                        vm.generateRainFile(durationSec.toInt(), selectedIntensity.code, mask, filename, seed)&#10;                                    },&#10;                                    status = status,&#10;                                    onRefresh = { vm.refreshList() }&#10;                                )&#10;                                Screen.RECORDINGS -&gt; RecordingsContent(&#10;                                    recordings = recordings,&#10;                                    currentPlaying = currentPlaying,&#10;                                    isPlayingGlobal = isPlayingGlobal,&#10;                                    onPlay = { vm.togglePlay(it) },&#10;                                    onDelete = { vm.deleteFile(it) },&#10;                                    onRefresh = { vm.refreshList() },&#10;                                    onRename = { file, newName -&gt;&#10;                                        val trimmed = newName.trim()&#10;                                        if (trimmed.isNotEmpty()) {&#10;                                            val safeName = if (trimmed.endsWith(&quot;.wav&quot;, ignoreCase = true)) trimmed else &quot;$trimmed.wav&quot;&#10;                                            val dir = file.parentFile&#10;                                            if (dir != null) {&#10;                                                val target = File(dir, safeName)&#10;                                                when {&#10;                                                    target.exists() -&gt; vm.updateStatus(&quot;error: rename target exists&quot;)&#10;                                                    file.renameTo(target) -&gt; {&#10;                                                        vm.updateStatus(&quot;renamed:${target.name}&quot;)&#10;                                                    }&#10;                                                    else -&gt; {&#10;                                                        vm.updateStatus(&quot;error: rename failed&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                        vm.refreshList()&#10;                                    }&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun modifierMask(key: String): Int {&#10;        return when (key) {&#10;            &quot;sea&quot; -&gt; 1 shl 0&#10;            &quot;cliffs&quot; -&gt; 1 shl 1&#10;            &quot;forest&quot; -&gt; 1 shl 2&#10;            &quot;river&quot; -&gt; 1 shl 3&#10;            &quot;city&quot; -&gt; 1 shl 4&#10;            &quot;countryside&quot; -&gt; 1 shl 5&#10;            &quot;cafe&quot; -&gt; 1 shl 6&#10;            else -&gt; 0&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun GeneratorContent(&#10;    selectedIntensity: RainIntensity,&#10;    onSelectIntensity: (RainIntensity) -&gt; Unit,&#10;    modifiers: MutableMap&lt;String, Boolean&gt;,&#10;    durationSec: Float,&#10;    onDurationChange: (Float) -&gt; Unit,&#10;    onGenerate: () -&gt; Unit,&#10;    status: String,&#10;    onRefresh: () -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.padding(16.dp).verticalScroll(rememberScrollState())) {&#10;        Spacer(Modifier.height(8.dp))&#10;&#10;        Text(&quot;Intensity&quot;)&#10;        Row(Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            listOf(RainIntensity.LIGHT, RainIntensity.MEDIUM, RainIntensity.HEAVY).forEach { r -&gt;&#10;                val isSelected = r == selectedIntensity&#10;                Button(&#10;                    onClick = { onSelectIntensity(r) },&#10;                    modifier = Modifier.weight(1f),&#10;                    colors = ButtonDefaults.buttonColors(&#10;                        containerColor = if (isSelected) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondaryContainer,&#10;                        contentColor = if (isSelected) MaterialTheme.colorScheme.onPrimary else MaterialTheme.colorScheme.onSecondary&#10;                    )&#10;                ) {&#10;                    Text(r.label)&#10;                }&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;        Text(&quot;Modifiers (environment)&quot;)&#10;        FlowRow(modifiers.keys.toList()) { key -&gt;&#10;            val checked = modifiers[key] ?: false&#10;            FilterChip(selected = checked, onClick = { modifiers[key] = !checked }, label = { Text(key) })&#10;        }&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;        Text(&quot;Duration: ${durationSec.toInt()}s&quot;)&#10;        Slider(value = durationSec, onValueChange = onDurationChange, valueRange = 10f..3000f)&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;        Row(horizontalArrangement = Arrangement.spacedBy(8.dp)) {&#10;            Button(onClick = onGenerate) { Text(&quot;Generate&quot;) }&#10;            Button(onClick = onRefresh) { Text(&quot;Refresh&quot;) }&#10;        }&#10;&#10;        Spacer(Modifier.height(8.dp))&#10;        Text(&quot;Status: $status&quot;)&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun RecordingsContent(&#10;    recordings: List&lt;File&gt;,&#10;    currentPlaying: String?,&#10;    isPlayingGlobal: Boolean,&#10;    onPlay: (File) -&gt; Unit,&#10;    onDelete: (File) -&gt; Unit,&#10;    onRefresh: () -&gt; Unit,&#10;    onRename: (File, String) -&gt; Unit&#10;) {&#10;    Column(modifier = Modifier.padding(16.dp)) {&#10;        Row(horizontalArrangement = Arrangement.SpaceBetween, modifier = Modifier.fillMaxWidth()) {&#10;            Text(&quot;Recordings&quot;, style = MaterialTheme.typography.titleMedium)&#10;            Button(onClick = onRefresh) { Text(&quot;Refresh&quot;) }&#10;        }&#10;        Spacer(Modifier.height(8.dp))&#10;        LazyColumn(verticalArrangement = Arrangement.spacedBy(4.dp)) {&#10;            items(recordings) { f -&gt;&#10;                val playingForThis = (currentPlaying == f.absolutePath) &amp;&amp; isPlayingGlobal&#10;                RecordingRow(&#10;                    file = f,&#10;                    isPlaying = playingForThis,&#10;                    onTogglePlay = { onPlay(f) },&#10;                    onDelete = { onDelete(f) },&#10;                    onRename = { newName -&gt; onRename(f, newName) }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun FlowRow(keys: List&lt;String&gt;, content: @Composable (String) -&gt; Unit) {&#10;    Column {&#10;        val maxPerRow = 3&#10;        keys.chunked(maxPerRow).forEach { chunk -&gt;&#10;            Row(horizontalArrangement = Arrangement.spacedBy(8.dp), modifier = Modifier.fillMaxWidth()) {&#10;                chunk.forEach { key -&gt; content(key) }&#10;            }&#10;            Spacer(Modifier.height(8.dp))&#10;        }&#10;    }&#10;}&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;private fun RecordingRow(&#10;    file: File,&#10;    isPlaying: Boolean,&#10;    onTogglePlay: () -&gt; Unit,&#10;    onDelete: () -&gt; Unit,&#10;    onRename: (String) -&gt; Unit&#10;) {&#10;    var showRenameDialog by remember { mutableStateOf(false) }&#10;    var newName by remember { mutableStateOf(file.name) }&#10;&#10;    Card(modifier = Modifier&#10;        .fillMaxWidth()&#10;        .padding(vertical = 4.dp)) {&#10;        Row(&#10;            modifier = Modifier&#10;                .padding(12.dp)&#10;                .fillMaxWidth(),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Column {&#10;                Text(file.name, style = MaterialTheme.typography.bodyLarge)&#10;                Text(&quot;${file.length() / 1024} KB&quot;, style = MaterialTheme.typography.bodySmall)&#10;            }&#10;            Row {&#10;                if (isPlaying) {&#10;                    TextButton(onClick = onTogglePlay) { Text(&quot;Pause&quot;) }&#10;                } else {&#10;                    IconButton(onClick = onTogglePlay) { Icon(Icons.Default.PlayArrow, contentDescription = &quot;Play&quot;) }&#10;                }&#10;                IconButton(onClick = { showRenameDialog = true }) {&#10;                    Icon(Icons.Default.Edit, contentDescription = &quot;Rename&quot;)&#10;                }&#10;                IconButton(onClick = onDelete) { Icon(Icons.Default.Delete, contentDescription = &quot;Delete&quot;) }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showRenameDialog) {&#10;        AlertDialog(&#10;            onDismissRequest = { showRenameDialog = false },&#10;            title = { Text(&quot;Rename recording&quot;) },&#10;            text = {&#10;                Column {&#10;                    Text(&quot;Enter a new name (without extension). .wav will be added if missing.&quot;)&#10;                    Spacer(Modifier.height(8.dp))&#10;                    TextField(value = newName, onValueChange = { newName = it }, singleLine = true)&#10;                }&#10;            },&#10;            confirmButton = {&#10;                TextButton(onClick = {&#10;                    onRename(newName)&#10;                    showRenameDialog = false&#10;                }) {&#10;                    Text(&quot;OK&quot;)&#10;                }&#10;            },&#10;            dismissButton = {&#10;                TextButton(onClick = { showRenameDialog = false }) { Text(&quot;Cancel&quot;) }&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun AppTopBar(currentScreen: Screen, onOpenRecordings: () -&gt; Unit, onBack: () -&gt; Unit) {&#10;    Surface(tonalElevation = 4.dp, modifier = Modifier.fillMaxWidth()) {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(horizontal = 16.dp, vertical = 12.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                if (currentScreen == Screen.GENERATOR) &quot;Rain Mix Generator&quot; else &quot;Recordings&quot;,&#10;                style = MaterialTheme.typography.titleLarge&#10;            )&#10;            if (currentScreen == Screen.GENERATOR) {&#10;                TextButton(onClick = onOpenRecordings) { Text(&quot;Recordings&quot;) }&#10;            } else {&#10;                TextButton(onClick = onBack) { Text(&quot;Back&quot;) }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/audio/RainGenerator.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/seattledevcamp/rainmaker/audio/RainGenerator.kt" />
              <option name="originalContent" value="package com.seattledevcamp.rainmaker.audio&#10;&#10;import kotlin.math.PI&#10;import kotlin.math.abs&#10;import kotlin.math.max&#10;import kotlin.random.Random&#10;&#10;object RainGenerator {&#10;    data class Layer(val amplitude: Float, val cutoffHz: Float, val density: Float)&#10;&#10;    fun generate(sampleRate: Int = 44100, durationSec: Int = 10, intensity: Int = 1, modifiersMask: Int = 0): ShortArray {&#10;        val totalSamples = sampleRate * durationSec&#10;        val rnd = Random(0)&#10;        val mix = FloatArray(totalSamples)&#10;&#10;        val layers = when (intensity) {&#10;            0 -&gt; listOf( // light&#10;                Layer(0.4f, 4000f, 0.6f),&#10;                Layer(0.2f, 1200f, 0.3f),&#10;                Layer(0.1f, 8000f, 0.15f)&#10;            )&#10;            2 -&gt; listOf( // heavy&#10;                Layer(0.9f, 6000f, 1.4f),&#10;                Layer(0.5f, 1500f, 0.9f),&#10;                Layer(0.3f, 9000f, 0.35f)&#10;            )&#10;            else -&gt; listOf( // medium&#10;                Layer(0.6f, 5000f, 1.0f),&#10;                Layer(0.35f, 1200f, 0.6f),&#10;                Layer(0.2f, 7000f, 0.25f)&#10;            )&#10;        }&#10;&#10;        // apply basic modifier effects&#10;        val adjustedLayers = layers.map { layer -&gt;&#10;            var amp = layer.amplitude&#10;            var density = layer.density&#10;            // forest -&gt; boost mids&#10;            if (modifiersMask and (1 shl 2) != 0) amp *= 1.05f&#10;            // city -&gt; boost highs&#10;            if (modifiersMask and (1 shl 4) != 0) amp *= 1.2f&#10;            Layer(amp, layer.cutoffHz, density)&#10;        }&#10;&#10;        for (layer in adjustedLayers) {&#10;            var prev = 0f&#10;            val rc = 1f / (2f * PI.toFloat() * layer.cutoffHz)&#10;            val dt = 1f / sampleRate.toFloat()&#10;            val alpha = dt / (rc + dt)&#10;            for (i in 0 until totalSamples) {&#10;                val white = (rnd.nextFloat() * 2f - 1f) * layer.amplitude&#10;                prev += alpha * (white - prev)&#10;                val env = if (rnd.nextFloat() &lt; (0.002f * layer.density)) 1f else 0.9f&#10;                mix[i] += prev * env&#10;            }&#10;        }&#10;&#10;        var peak = 0f&#10;        for (v in mix) peak = max(peak, abs(v))&#10;        if (peak &lt; 1e-6f) peak = 1f&#10;        val scale = 0.9f * Short.MAX_VALUE / peak&#10;        val out = ShortArray(totalSamples)&#10;        for (i in mix.indices) {&#10;            val scaled = (mix[i] * scale).coerceIn(Short.MIN_VALUE.toFloat(), Short.MAX_VALUE.toFloat())&#10;            out[i] = scaled.toInt().toShort()&#10;        }&#10;        return out&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.seattledevcamp.rainmaker.audio&#13;&#10;&#13;&#10;import kotlin.math.PI&#13;&#10;import kotlin.math.abs&#13;&#10;import kotlin.math.max&#13;&#10;import kotlin.random.Random&#13;&#10;&#13;&#10;object RainGenerator {&#13;&#10;    data class Layer(val amplitude: Float, val cutoffHz: Float, val density: Float)&#13;&#10;&#13;&#10;    // Added `seed` parameter to guarantee unique output per run when seed differs.&#13;&#10;    fun generate(sampleRate: Int = 44100, durationSec: Int = 10, intensity: Int = 1, modifiersMask: Int = 0, seed: Long = Random.nextLong()): ShortArray {&#13;&#10;        val totalSamples = sampleRate * durationSec&#13;&#10;        // Initialize PRNG with provided seed so same settings + different seed =&gt; different audio&#13;&#10;        val rnd = Random(seed)&#13;&#10;        val mix = FloatArray(totalSamples)&#13;&#10;&#13;&#10;        val layers = when (intensity) {&#13;&#10;            0 -&gt; listOf( // light&#13;&#10;                Layer(0.4f, 4000f, 0.6f),&#13;&#10;                Layer(0.2f, 1200f, 0.3f),&#13;&#10;                Layer(0.1f, 8000f, 0.15f)&#13;&#10;            )&#13;&#10;            2 -&gt; listOf( // heavy&#13;&#10;                Layer(0.9f, 6000f, 1.4f),&#13;&#10;                Layer(0.5f, 1500f, 0.9f),&#13;&#10;                Layer(0.3f, 9000f, 0.35f)&#13;&#10;            )&#13;&#10;            else -&gt; listOf( // medium&#13;&#10;                Layer(0.6f, 5000f, 1.0f),&#13;&#10;                Layer(0.35f, 1200f, 0.6f),&#13;&#10;                Layer(0.2f, 7000f, 0.25f)&#13;&#10;            )&#13;&#10;        }&#13;&#10;&#13;&#10;        // apply basic modifier effects&#13;&#10;        val adjustedLayers = layers.map { layer -&gt;&#13;&#10;            var amp = layer.amplitude&#13;&#10;            var density = layer.density&#13;&#10;            // forest -&gt; boost mids&#13;&#10;            if (modifiersMask and (1 shl 2) != 0) amp *= 1.05f&#13;&#10;            // city -&gt; boost highs&#13;&#10;            if (modifiersMask and (1 shl 4) != 0) amp *= 1.2f&#13;&#10;            Layer(amp, layer.cutoffHz, density)&#13;&#10;        }&#13;&#10;&#13;&#10;        for (layer in adjustedLayers) {&#13;&#10;            var prev = 0f&#13;&#10;            val rc = 1f / (2f * PI.toFloat() * layer.cutoffHz)&#13;&#10;            val dt = 1f / sampleRate.toFloat()&#13;&#10;            val alpha = dt / (rc + dt)&#13;&#10;            for (i in 0 until totalSamples) {&#13;&#10;                val white = (rnd.nextFloat() * 2f - 1f) * layer.amplitude&#13;&#10;                prev += alpha * (white - prev)&#13;&#10;                val env = if (rnd.nextFloat() &lt; (0.002f * layer.density)) 1f else 0.9f&#13;&#10;                mix[i] += prev * env&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        var peak = 0f&#13;&#10;        for (v in mix) peak = max(peak, abs(v))&#13;&#10;        if (peak &lt; 1e-6f) peak = 1f&#13;&#10;        val scale = 0.9f * Short.MAX_VALUE / peak&#13;&#10;        val out = ShortArray(totalSamples)&#13;&#10;        for (i in mix.indices) {&#13;&#10;            val scaled = (mix[i] * scale).coerceIn(Short.MIN_VALUE.toFloat(), Short.MAX_VALUE.toFloat())&#13;&#10;            out[i] = scaled.toInt().toShort()&#13;&#10;        }&#13;&#10;        return out&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>